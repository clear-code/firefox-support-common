#!/usr/bin/env python3
# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this
# file, You can obtain one at http://mozilla.org/MPL/2.0/.
#
# build-xlsx - Generate a spread sheet from files
#
# USAGE
#
# (1) Output an empty sheet
#
#     $ build-xlsx -o config.xlsx
#
# (2) Generate a filled sheet
#
#     $ build-xlsx esr91.txt esr102.txt ... verify-targets-to-chapters.csv
#     $ build-xlsx -p esr91.txt -c esr102.txt
#     $ build-xlsx -d ESR91:esr91.txt -d ESR102:esr102.txt -d "ESR102 variation:esr102-variation.txt"
#
# DEFINITION OF TERMS IN THIS MODULE
#
#     For example, about "Security-9-3 about:configの利用の可否：禁止する" on Firefox ESR102:
#
#     * category:   "Security", this is same to the name of the file under "esr102/"
#     * item:       "Security-9"
#       * items:    "Security-1", "Security-2", "Security-3", and others defined in the file "esr102/Security"
#     * option:     "Security-9-1", "Security-9-2", "Security-9-3", and others
#       * config:   `"BlockAboutConfig": true,` or others, defined in the given "conf" file like "esr102.txt"
#       * template: `"BlockAboutConfig": true,` or others, defined in the file "esr102/Security"
#
#     * conf:       A file listing chosen options. Please note this is not an abbr of "config".
#     * curr/prev:  curr=ESR102, prev=ESR91 (versions)

import re
import sys
import glob
import getopt
import csv
import os
import yaml
import traceback

BASEDIR = os.path.dirname(os.path.realpath(__file__))
sys.path.append(BASEDIR)

import adlib
try:
    import xlsxwriter
    from xlsxwriter.utility import xl_rowcol_to_cell
except ImportError:
    print('ERROR: Please install xlswriter to run this script\n')
    print('  $ sudo apt install python3-xlsxwriter\n')
    sys.exit(1)

#
# Global settings

ESR_PREVIOUS = 'esr91'
ESR_CURRENT  = 'esr102'
CHAPTERS_CSV = 'verify-targets-to-chapters.csv'

# allow to override
esr_previous_version = ESR_PREVIOUS
esr_current_version = ESR_CURRENT
base_dir = BASEDIR

WORKBOOKS = [
    ('基本設定', [
        'Install',
        'Application',
        'Admin',
        'Security',
        'Privacy',
        'Startup',
        'Websearch',
        'Location',
        'Download',
        'Tab',
        'Network',
        'Update',
        'Ui',
        'Script',
        'Plugin',
        'External',
        'Stability',
        'Appearance',
        'Performance',
        'Addon-IEView',
        'Addon-FireIE',
        'Addon-Acrobat',
        'Addon-Skysea',
    ]),
    ('機能無効化', [
        'MenuShortcut',
    ]),
]

DEFAULT_FORMAT = {
    'valign':    'top',
    'border':    1,
    'font_size': 8,
    'font_name': 'MS Gothic',
    'text_wrap': 1,
}

CATEGORY_COLUMNS = [ # label, width, key, format
    ('カテゴリー',              10, 'category', 'default'),
]

HEADING_COLUMNS = [ # label, width, key, format
    ('項目設定番号',            10, 'index',    None),
    ('カスタマイズ項目 (目的)', 30, 'title',    None),
]

LEADING_COLUMNS = [ # label, width, key, format
    ('選択肢番号',              5,  'option_index',    None),
    ('選択肢',                  20, 'option_title',    None),
    ('設定内容の雛形\n(%s)' % ESR_CURRENT.upper(),
                                40, 'template_config', None),
]

def variation_columns(version, prev_version):
    return [ # label, width, key, format
        ('反映した設定値\n(%s)' % version,           40, None, None),
        ('%s→%sでの変更' % (prev_version, version), 10, None, None),
    ]

VERIFICATION_COLUMNS = [ # label, width, key, format
    ('検証手順書対応番号', 10, 'verification_chapter', 'default'),
    ('',                   12, None,                   'noborder'),
]

PREV_VERSION_COLUNBS = [ # label, width, key, format
    ('設定内容の雛形\n(%s)' % ESR_PREVIOUS.upper(), 40, 'template_prev_config', None),
    ('反映した設定値\n(%s)' % ESR_PREVIOUS.upper(), 40, 'applied_prev_config',  None),
]

check_template_mode = False
verbose_mode = False

#
# XLSX writer

import pprint

class ConfigurationSheet:

    def __init__(self, confs, formats, sheet, esr_previous_version, esr_current_version):
        self._confs   = confs
        self._formats = formats
        self._sheet   = sheet
        self._metadata = {}
        self._esr_previous_version = esr_previous_version
        self._esr_current_version = esr_current_version

    def iterate_all_confs(self):
        return self._confs.items()

    def write_cell(self, row, column, contents, format):
        self._sheet.write(row, column, contents, self._formats[format])

    def write_comment(self, row, column, contents, format):
        cell = xl_rowcol_to_cell(row, column)
        self._sheet.write_comment(cell, contents, format)

    def _set_cell_visual(self, row, column, width, format = None):
        if format:
            self._sheet.set_column(row, column, width, self._formats[format])
        else:
            self._sheet.set_column(row, column, width)

    def write_header(self):
        sheet = self._sheet

        sheet.freeze_panes(1, 0)
        sheet.set_row(0, 25)

        column_offset = 0
        column_offset += self._write_header_columns(CATEGORY_COLUMNS, 0)
        column_offset += self._write_header_columns(HEADING_COLUMNS, column_offset)
        column_offset += self._write_header_columns(LEADING_COLUMNS, column_offset)

        last_variation = self._esr_previous_version.upper()
        for variation in self._confs.keys():
            if variation == self._esr_previous_version.upper():
                continue
            columns = variation_columns(variation, last_variation)
            column_offset += self._write_header_columns(columns, column_offset)
            last_variation = variation

        column_offset += self._write_header_columns(VERIFICATION_COLUMNS, column_offset)
        column_offset += self._write_header_columns(PREV_VERSION_COLUNBS, column_offset)

    def _write_header_columns(self, columns, column_offset):
        for index, column in enumerate(columns):
            label, width, _key, _format = column
            self.write_cell(0, column_offset + index, label, 'center')
            self._set_cell_visual(column_offset + index, column_offset + index, width)
        return len(columns)

    def merge_category_heading(self, row, items):
        for index, _column in enumerate(CATEGORY_COLUMNS):
            self._sheet.merge_range(row, index, row + self._count_options(items) - 1, index, '')

    def _count_options(self, items):
        return sum(len(item['options']) for item in items)

    def try_merge_item_heading(self, row, item):
        if len(item['options']) <= 1:
            return
        sheet = self._sheet
        column_offset = len(CATEGORY_COLUMNS)
        for index, _column in enumerate(HEADING_COLUMNS):
            sheet.merge_range(row, column_offset + index, row + len(item['options']) - 1, column_offset + index, '')

    def write_legend(self, row):
        self.write_cell(row,     1, '',                                     'selected')
        self.write_cell(row,     2, '前バージョンから引き続き利用する項目', 'noborder')
        self.write_cell(row + 1, 1, '',                                     'selected_changed')
        self.write_cell(row + 1, 2, '前バージョンから異同がある項目',       'noborder')
        self.write_cell(row + 2, 1, '',                                     'deprecated')
        self.write_cell(row + 2, 2, '廃止済みの項目',                       'noborder')
        if check_template_mode:
            self.write_cell(row + 3, 1, '',                                   'mismatched')
            self.write_cell(row + 3, 2, '新しい設定値に追従できていない項目',    'noborder')
            self.write_cell(row + 4, 1, '',                                   'invalid')
            self.write_cell(row + 4, 2, '設定値の記述書式が誤っている項目',       'noborder')

    def _parse_config(self, config):
        try:
            parsed = yaml.safe_load(config)
            return parsed
        except yaml.YAMLError as e:
            return {}

    def build_metadata(self, key, items):
        conflict_with = self._build_metadata_for('conflict_with', items)
        forced_by = self._build_metadata_for('forced_by', items)
        if key in self._metadata.keys():
            conflict_with.update(self._metadata[key]['conflict_with'])
            forced_by.update(self._metadata[key]['forced_by'])
        self._metadata[key] = {
            'conflict_with': conflict_with,
            'forced_by': forced_by
        }

    def _get_meta_config(self, key, config):
        data = None
        parsed = self._parse_config(config)
        if type(parsed) is str:
            pass
        elif parsed == [None]:
            pass
        elif parsed == None:
            pass
        elif key in parsed.keys():
            data = parsed[key]
        return data

    def _build_metadata_for(self, key, items):
        data = {}
        for item in items:
            if type(item) is str:
                config = items[item]['config']
                values = self._get_meta_config(key, config)
                if values:
                    data[item] = values
            else:
                for option in item['options']:
                    option_id = option['option_id']
                    config = option['config']
                    values = self._get_meta_config(key, config)
                    if values:
                        data[option_id] = values
        return data

class ConfigurationRow:

    def __init__(self, sheet, index, item, option, category,
                 prev_conf, prev_items, verification_chapters, base_items,
                 esr_previous_version, esr_current_version):
        self._sheet                 = sheet
        self._index                 = index
        self._item                  = item
        self._option                = option
        self._category              = category
        self._prev_conf             = prev_conf
        self._verification_chapters = verification_chapters
        self._verification_chapter  = ''
        self._base_items            = base_items

        self._prev_config           = self._get_option_config(self._prev_conf)
        self._template_prev_config  = self._get_option_config(prev_items)
        self._template_curr_config  = option['config'].strip()

        self._esr_previous_version  = esr_previous_version
        self._esr_current_version   = esr_current_version

    def _get_option_config(self, conf_or_items):
        found_option = conf_or_items.get(self._option['option_id'])
        if not found_option:
          return ''
        return found_option['config']

    def write(self):
        column_offset = 0
        column_offset += self._write_item_columns(CATEGORY_COLUMNS)

        # Heading column must be written for all rows, otherwise merged cells will have
        # a partial border line just for the first row.
        heading_format = 'default'
        if self._is_deprecated(self._item['title']):
            heading_format = 'deprecated'
        column_offset += self._write_item_columns(HEADING_COLUMNS, heading_format, column_offset)

        # Don't output leading columns here, because they depends on the format calculated for variation columns
        column_offset += len(LEADING_COLUMNS)
        column_count, format = self._write_item_variations_columns(column_offset)
        column_offset += column_count

        # Now we are ready to fill leading columns!
        self._write_item_columns(LEADING_COLUMNS, format, len(CATEGORY_COLUMNS + HEADING_COLUMNS))

        column_offset += self._write_item_columns(VERIFICATION_COLUMNS, format, column_offset)
        column_offset += self._write_item_columns(PREV_VERSION_COLUNBS, format, column_offset)

    def _write_column(self, column, contents, format):
        self._sheet.write_cell(self._index, column, contents, format)

    def _write_comment(self, column, comment, format = {'visible': False}):
        # It seems that showing comment by default may be noisy.
        self._sheet.write_comment(self._index, column, comment, format)

    def _write_item_columns(self, columns, format = 'default', column_offset = 0):
        for index, column in enumerate(columns):
            label, width, key, override_format = column
            self._write_column(column_offset + index, self._get_column_value(key), override_format or format)
            parsed = None
            if key in ['template_config', 'template_prev_config', 'applied_prev_config']:
                if key == 'template_config':
                    parsed = self._parse_config(self._template_curr_config)
                elif key == 'template_prev_config':
                    parsed = self._parse_config(self._template_prev_config)
                elif key == 'applied_prev_config':
                    parsed = self._parse_config(self._prev_config)
            if type(parsed) is dict and 'comment' in parsed.keys():
                    self._write_comment(column_offset + index, parsed['comment'])
        return len(columns)

    def _get_column_value(self, key):
        if key == 'category':
            return self._category
        elif key == 'index':
            return int(self._item['index'])
        elif key == 'title':
            return self._item['title']
        elif key == 'option_index':
            return int(self._option['option_index'])
        elif key == 'option_title':
            return self._option['option_title']
        elif key == 'template_config':
            return self._concat_column_value(key, self._template_curr_config)
        elif key == 'verification_chapter':
            return self._verification_chapter;
        elif key == 'template_prev_config':
            return self._concat_column_value(key, self._template_prev_config)
        elif key == 'applied_prev_config':
            return self._concat_column_value(key, self._prev_config)
        else:
            return ''

    def _write_item_variations_columns(self, column_offset):
        option_id = self._option['option_id']

        column_count         = 0
        row_format           = 'default'
        verification_chapter = ''

        last_conf   = self._prev_conf
        last_config = self._prev_config
        for version, conf in self._sheet.iterate_all_confs():
            if version == self._esr_previous_version:
                continue

            config         = self._get_option_config(conf)
            format, status = self._determine_format_and_status(conf, last_conf, last_config)

            if last_conf == self._prev_conf:
              row_format = format

            if option_id in conf:
                self._verification_chapter = self._verification_chapters.get(option_id, '省略')

                # check conflict with (selected option -> candidates)
                conflict_with = None
                if self._esr_current_version.upper() in self._sheet._metadata.keys():
                    conflict_with = self._sheet._metadata[self._esr_current_version.upper()]['conflict_with']
                conflicted = False
                if conflict_with != None:
                    if option_id in conflict_with:
                        for conflicted_id in conflict_with[option_id]:
                            if conflicted_id in conf.keys():
                                message = "%s と %s は同時に選択することができない項目です。" % (option_id, conflicted_id)
                                self._write_comment(column_offset + column_count + 2, message,
                                                    {'visible': True, 'color': '#ff4b00', 'font_size': 7})
                                conflicted = True
                if conflicted is False and conflict_with:
                    # check reverse conflicted rule (option is candidates of other selected option)
                    for key in conflict_with.keys():
                        for candidate in conflict_with[key]:
                            if option_id == candidate and key in conf.keys():
                                message = "%s と %s は同時に選択することができない項目です。" % (option_id, key)
                                self._write_comment(column_offset + column_count + 2, message,
                                                    {'visible': True, 'color': '#ff4b00', 'font_size': 7})

            else:
                forced_by = self._sheet._metadata[self._esr_current_version.upper()]['forced_by']
                if forced_by != None and option_id in forced_by:
                    for candidate in forced_by[option_id]:
                        if candidate in conf.keys():
                            parsed_config = self._parse_config(config)
                            if type(parsed_config) is dict and 'default' in parsed_config.keys() and parsed_config['default']:
                                # not selected but if options_id is default, it is ok.
                                pass
                            else:
                                message = "%s は %s の適用により自動的に挙動が決まるため、選択していないと矛盾します。" % (option_id, candidate)
                                self._write_comment(column_offset + column_count + 2, message,
                                                {'visible': True, 'color': '#ff4b00', 'font_size': 7})

            self._write_column(column_offset + column_count,     self._concat_column_value(None, config), format)
            self._write_column(column_offset + column_count + 1, status, format)


            if format == 'invalid':
                message = "設定値の記述に誤りがあります。\n例: 反映する設定値にタブが含まれている\n不要な,が含まれている"
                self._write_comment(column_offset + column_count + 1, message,
                                    {'visible': True, 'color': '#ff4b00', 'font_size': 7})

            parsed_config = self._parse_config(config)
            if type(parsed_config) is dict and 'comment' in parsed_config.keys():
                self._write_comment(column_offset + column_count, parsed_config['comment'])

            column_count += 2
            last_conf   = conf
            last_config = config

        return [column_count, row_format]

    def _determine_format_and_status(self, conf, last_conf, last_config):
        option    = self._option
        option_id = option['option_id']

        status   = ''
        format   = 'default'
        config   = self._get_option_config(conf)

        valid_config = True
        valid_last_config = True
        try:
            valid_last_config = self._validate_syntax(last_config)
        except yaml.YAMLError as e:
            print('ERROR: %s: syntax of %s is wrong: %s' % (option_id, self._esr_previous_version, last_config))
        try:
            valid_config = self._validate_syntax(config)
        except yaml.YAMLError as e:
            print('ERROR: %s: syntax of %s is wrong: %s' % (option_id, self._esr_current_version, config))

        modified = self._sanitize_config(None, last_config) != self._sanitize_config(None, config)
        check_template = self._is_follow_new_template(option_id, config)

        if self._is_deprecated(self._item['title']) or self._is_deprecated(option['option_title']):
            format = 'deprecated'
        elif option_id in conf:
            if option_id not in last_conf:
                format, status = 'selected_changed', '新規'
            elif modified:
                format, status = 'selected_changed', '変更あり'
            elif check_template:
                print('WARNING: %s %s is same as %s, but a bit different from current %s template:' %
                      (option_id, self._esr_current_version,
                       self._esr_previous_version, self._esr_current_version))
                format, status = 'mismatched', '反映値要確認(雛形との差分)'
            else:
                format, status = 'selected', ''
            if check_template_mode:
                if not valid_last_config and not valid_config:
                    format = 'invalid'
                    status += '%s & %s %s' % (self._esr_previous_version, self._esr_current_version, '反映値要確認(構文エラー)')
                elif not valid_last_config:
                    format = 'invalid'
                    status +=  self._esr_previous_version + '反映値要確認(構文エラー)'
                elif not valid_config:
                    format, status = 'invalid', self._esr_current_version + '反映値要確認(構文エラー)'
        elif last_conf == self._prev_conf:
            if self._modified_from_prev_version():
              if self._added_at_this_version():
                  format, status = 'changed', '新規（未設定）'
              else:
                  format, status = 'changed', '変更あり（未設定）'
        else:
            if modified:
                status = '削除'

        return [format, status]

    def _modified_from_prev_version(self):
        return self._sanitize_config(None, self._template_curr_config) != self._sanitize_config(None, self._template_prev_config)

    def _added_at_this_version(self):
        return self._template_prev_config == ''

    def _is_deprecated(self, string):
        return '廃止' in string

    def _contains_unknown_key(self, config):
        for key in config.keys():
            if key in ['note', 'comment', 'default',
                       'config_nsh', 'firefox_setup_ini',
                       'fainstall_ini',
                       'cfg_or_jsc', 'cfg', 'policies_json']:
                pass
            else:
                return True

    def _validate_syntax(self, config):
        try:
            parsed = self._parse_config(config, True)
            if type(parsed) is str:
                return True
            elif parsed == [None]:
                return True
            elif parsed is None:
                return True
            else:
                if self._contains_unknown_key(parsed):
                    return False
            return True
        except yaml.YAMLError as e:
            return False

    def _parse_config(self, config, raiseYAMLError=False):
        try:
            parsed = yaml.safe_load(config)
            return parsed
        except yaml.YAMLError as e:
            if raiseYAMLError:
                raise e
            else:
                return {'error': e}

    #
    # Concat column text from config
    # It returns finalized cell content
    #
    def _concat_column_value(self, key, config):
        parsed = self._parse_config(config)
        if type(parsed) is str:
            return parsed
        elif parsed == [None]:
            return '-' # - is parsed as [None]
        elif parsed is None:
            return '' # empty config

        data = ""
        if any(['config_nsh' in parsed.keys(),
                'firefox_setup_ini' in parsed.keys(),
                'fainstall_ini' in parsed.keys(),
                'cfg_or_jsc' in parsed.keys()]):
            if 'note' in parsed.keys():
               data += "%s\n" % (parsed['note'])
        if 'config_nsh' in parsed.keys():
            data += "config.nsh:\n" + parsed['config_nsh']
        if 'firefox_setup_ini' in parsed.keys():
            data += "Firefox-setup.ini:\n" + parsed['firefox_setup_ini']
        if 'fainstall_ini' in parsed.keys():
            data += "fainstall.ini:\n" + parsed['fainstall_ini']
        if 'cfg_or_jsc' in parsed.keys():
            data += "*.cfg / *.js:\n%s\n" % (parsed['cfg_or_jsc'])
        elif 'combined' in parsed.keys() and 'cfg' in parsed.keys() and 'policies_json' in parsed.keys():
            if 'note' in parsed.keys():
                data += "autoconfig.cfg:\n%s\n%s\n%s\n" % (parsed['cfg'], parsed['note'], parsed['policies_json'])
            else:
                data += "autoconfig.cfg:\n%s\n" % (parsed['cfg'], parsed['policies_json'])
        elif 'cfg' in parsed.keys():
            if 'note' in parsed.keys():
                data += "autoconfig.cfg:\n%s\n%s\n" % (parsed['note'], parsed['cfg'])
            else:
                data += "autoconfig.cfg:\n%s\n" % (parsed['cfg'])
        if 'policies_json' in parsed.keys():
            if 'note' in parsed.keys():
                data += "%s\ndistribution\policies.json:\n%s" % (parsed['note'], parsed['policies_json'])
            else:
                data += "distribution\policies.json:\n%s" % (parsed['policies_json'])
        if 'default' in parsed.keys() and parsed['default']:
            data += '-'
        return data

    # Return concatenated configuration text.
    # It only contains configuration (without note, comment, file name and so on)
    def _sanitize_config(self, key, config):
        # return re.sub(' *[^:]+:\n', '', config).strip()
        if config == '-' or config == '':
            return config
        else:
            data = ""
            try:
                parsed = yaml.safe_load(config)
                if parsed == None:
                    return config # '-'

                if type(parsed) is str:
                    return parsed
                elif type(parsed) is dict:
                    pass
                else:
                    print(type(parsed))
                    print(parsed)

                if 'config_nsh' in parsed.keys():
                    data += parsed['config_nsh']
                if 'firefox_setup_ini' in parsed.keys():
                    data += parsed['firefox_setup_ini']
                if 'fainstall_ini' in parsed.keys():
                    data += parsed['fainstall_ini']
                template = False
                if 'cfg_or_jsc' in parsed.keys():
                    data += parsed['cfg_or_jsc']
                if 'cfg' in parsed.keys():
                    data += parsed['cfg']
                if 'policies_json' in parsed.keys():
                    data += parsed['policies_json']
                if 'default' in parsed.keys() and parsed['default']:
                    data += "-"

            except yaml.YAMLError as e:
                return traceback.format_exception_only(type(e), e)[0]
            return data

    def _omit_redundant_config(self, config):
        config = re.sub('.*\*\.cfg', '*.cfg', config, flags=(re.DOTALL)).strip()
        config = self._omit_gpo_config(config)
        return config

    def _omit_gpo_config(self, config):
        # eliminate GPO: and the following configuration lines
        return re.sub('GPO:.*', '', config, flags=(re.DOTALL)).strip()

    def _is_follow_new_template(self, option_id, config):
        if not check_template_mode:
            return False
        if option_id in ('Install-1-2', 'Install-2-2', 'Install-7-2'):
            # Ignore always customized value
            return False
        if len(config) == 0:
            return False
        return self._sanitize_config(None, self._template_curr_config) != self._sanitize_config(None, config)

def generate_xlsx(workbook, confs, verification_chapters, exclude_worksheets,
                  base_dir, esr_previous_version, esr_current_version):

    formats = create_formats(workbook)
    prev_conf = confs[esr_previous_version.upper()]

    for title, sources in WORKBOOKS:
        if title in exclude_worksheets:
            continue

        sheet = ConfigurationSheet(
            confs,
            formats,
            workbook.add_worksheet(title),
            esr_previous_version,
            esr_current_version
        )
        sheet.write_header()

        row_index = 1

        # Generate metadata for conflict, forced by dependency
        for source in sources:
            source_path = os.path.join(base_dir, esr_current_version, source)
            if os.path.isfile(source_path):
                base_items = adlib.load(os.path.join(base_dir, esr_current_version, source))
                sheet.build_metadata(esr_current_version.upper(), base_items)
            else:
                print("WARNING: no %s" % source_path)

            source_path = os.path.join(base_dir, esr_previous_version, source)
            if os.path.isfile(source_path):
                prev_items = adlib.load_as_dict(source_path)
                sheet.build_metadata(esr_previous_version.upper(), prev_items)
            else:
                print("WARNING: no %s" % source_path)

        for source in sources:
            # We always output items based on sources for the current version.
            # In other words, the "current version" needs to define all deprecated/obsolete items
            # if they still need to be visible in the output sheet.
            source_path = os.path.join(base_dir, esr_current_version, source)
            base_items = {}
            prev_items = {}
            if os.path.isfile(source_path):
                base_items = adlib.load(source_path)
            source_path = os.path.join(base_dir, esr_previous_version, source)
            if os.path.isfile(source_path):
                prev_items = adlib.load_as_dict(source_path)
            if verbose_mode:
                print("Loading: %s" % os.path.join(base_dir, esr_current_version, source))
                print("Loading: %s" % os.path.join(base_dir, esr_previous_version, source))


            sheet.merge_category_heading(row_index, base_items)

            for item in base_items:
                sheet.try_merge_item_heading(row_index, item)

                for option in item['options']:
                    row = ConfigurationRow(
                        sheet,
                        row_index,
                        item,
                        option,
                        source,
                        prev_conf,
                        prev_items,
                        verification_chapters,
                        base_items,
                        esr_previous_version,
                        esr_current_version
                    )
                    row.write()
                    row_index += 1

        sheet.write_legend(row_index + 1)

def create_formats(workbook):
    def new_format(**kwargs):
        return workbook.add_format(dict(DEFAULT_FORMAT, **kwargs))
    return {
        'default':          new_format(),
        'noborder':         new_format(border = 0),
        'center':           new_format(align = 'center'),
        'changed':          new_format(bold = True),
        'deprecated':       new_format(bg_color = '#dddddd'),
        'question':         new_format(bg_color = '#90ee90'),
        'selected':         new_format(bg_color = '#fffa95'),
        'selected_changed': new_format(bg_color = '#ffb571'),
        'mismatched':       new_format(bg_color = '#f2e700'),
        'invalid':          new_format(bg_color = '#ff4b00'),
    }

#
# main

def load_verification_chapters(path):
    try:
        with open(path) as file:
            return dict(csv.reader(file))
    except FileNotFoundError:
        return {}

def main(args):
    global check_template_mode, base_dir, esr_previous_version, esr_current_version
    confs   = {}
    outfile = 'config.xlsx'
    exclude_worksheets = []

    opts, args = getopt.getopt(args, 'b:o:x:p:c:d:tv')
    for key, value in opts:
        if key == '-b':
            base_dir = value
        if key == '-o':
            outfile = value
        elif key == '-x':
            exclude_worksheets = value.split(',')
        elif key == '-p':
            confs[esr_previous_version.upper()] = value
        elif key == '-c':
            confs[esr_current_version.upper()] = value
        elif key == '-d':
            parts = value.split(':', 1)
            # specify previous, current order
            if not parts[0] in confs.keys():
                esr_previous_version = parts[0].lower()
            else:
                esr_current_version = parts[0].lower()
            confs[parts[0]] = parts[1]
        elif key == '-v':
            verbose_mode = True
        elif key == '-t':
            # Compare template configuration and finally applied configuration.
            # Do not use this option for sheet in production. This option is intended to be used with checking.
            check_template_mode = True

    verification_chapters = {}
    for arg in args:
        if esr_previous_version in arg and not esr_previous_version.upper() in confs:
            print('%s -> %s' % (esr_previous_version, arg))
            confs[esr_previous_version.upper()] = arg
        elif esr_current_version in arg and not esr_current_version.upper() in confs:
            print('%s -> %s' % (esr_current_version, arg))
            confs[esr_current_version.upper()] = arg
        elif CHAPTERS_CSV in arg:
            print('Loading', os.path.basename(arg))
            verification_chapters = load_verification_chapters(arg)

    for version, path in confs.items():
        confs[version] = adlib.load_as_dict(path)

    with xlsxwriter.Workbook(outfile) as workbook:
        generate_xlsx(workbook, confs, verification_chapters, exclude_worksheets,
                      base_dir, esr_previous_version, esr_current_version)

    print('Generated:', workbook.filename)

if __name__ == '__main__':
    sys.exit(main(sys.argv[1:]))
